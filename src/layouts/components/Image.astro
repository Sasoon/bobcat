---
interface Props {
  uuid: string;
  alt: string;
  sizes?: string;
  breakpoints?: number[];
  className?: string;
  crop?: boolean;
  isBackground?: boolean;
  forceSquare?: boolean;
}

interface ImageDimensions {
  width: number;
  height: number;
}

const {
  uuid,
  alt,
  sizes = "sm:100vw md:50vw lg:33vw",
  breakpoints = [640, 768, 1024, 1280, 1536],
  className = "",
  crop = false,
  isBackground = false,
  forceSquare = false,
} = Astro.props as Props;

const baseUrl = `https://ucarecdn.com/${uuid}/`;

import imageDimensions from "./imageDimensions.json";

async function fetchImageDimensions(uuid: string): Promise<ImageDimensions> {
  // Check pre-fetched dimensions
  if (imageDimensions[uuid]) {
    return imageDimensions[uuid];
  } else {
    console.log("no img dimension");
  }
}

const { width: originalWidth, height: originalHeight } =
  await fetchImageDimensions(uuid);
const aspectRatio = forceSquare ? 1 : originalWidth / originalHeight;

function generateSrcSet(
  breakpoints: number[],
  aspectRatio: number,
  crop: boolean,
): string {
  const srcSet = breakpoints
    .map((width) => {
      const height = Math.round(width / aspectRatio);
      const cropParam = crop
        ? `-/crop/${width}x${height}/center/`
        : `-/resize/${width}x${height}/`;
      return `${baseUrl}${cropParam}-/format/auto/-/quality/smart/ ${width}w`;
    })
    .join(", ");
  return srcSet;
}

function parseTailwindSizes(sizes: string): string {
  const breakpointMap: { [key: string]: number } = {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    "2xl": 1536,
  };

  const parts = sizes.split(" ").reverse();
  const result: string[] = [];

  for (const part of parts) {
    const [breakpoint, size] = part.split(":");
    if (breakpoint && breakpointMap[breakpoint]) {
      result.push(`(min-width: ${breakpointMap[breakpoint]}px) ${size}`);
    } else {
      result.push(size);
    }
  }

  return result.join(", ");
}

const srcset = generateSrcSet(breakpoints, aspectRatio, crop);
const parsedSizes = parseTailwindSizes(sizes);
const largestBreakpoint = breakpoints[breakpoints.length - 1];
const largestHeight = Math.round(largestBreakpoint / aspectRatio);
const cropParam = crop
  ? `-/crop/${largestBreakpoint}x${largestHeight}/center/`
  : `-/resize/${largestBreakpoint}x${largestHeight}/`;
const largestImageUrl = `${baseUrl}${cropParam}-/format/auto/-/quality/smart/`;
const largestBackgroundImageUrl = `${baseUrl}-/resize/${largestBreakpoint}x${largestHeight}/-/format/auto/-/quality/smart/`;

function generateLowResSrc(uuid: string): string {
  return `${baseUrl}-/resize/20x/-/format/auto/-/quality/lightest/`;
}

const lowResImageUrl = generateLowResSrc(uuid);
const highResImageUrl = largestImageUrl;
---

{
  isBackground ? (
    <div
      class={`cs-background ${className}`}
      style={`
      background-image: url('${largestBackgroundImageUrl}');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      aspect-ratio: ${aspectRatio};
    `}
      role="img"
      aria-label={alt}
    />
  ) : (
    <div class="image-container" style={`aspect-ratio: ${aspectRatio};`}>
      <img
        src={lowResImageUrl}
        alt={alt}
        class={`low-res ${className}`}
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;"
      />
      <img
        src={highResImageUrl}
        data-src={highResImageUrl}
        srcset={srcset}
        sizes={parsedSizes}
        alt={alt}
        loading="lazy"
        decoding="async"
        width={largestBreakpoint}
        height={largestHeight}
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.3s ease-in-out;"
        class={`high-res ${className}`}
      />
    </div>
  )
}

<style>
  .image-container {
    position: relative;
    overflow: hidden;
  }
  .low-res {
    filter: blur(20px);
    transition: opacity 0.3s ease-in;
  }
  .high-res {
    transition: opacity 0.3s ease-in;
  }
</style>

<script>
  function loadHighResImage(container: HTMLElement): void {
    const lowResImg = container.querySelector(".low-res") as HTMLImageElement;
    const highResImg = container.querySelector(".high-res") as HTMLImageElement;

    if (highResImg.complete) {
      showHighResImage(lowResImg, highResImg);
    } else {
      highResImg.onload = () => showHighResImage(lowResImg, highResImg);
    }
  }

  function showHighResImage(
    lowResImg: HTMLImageElement,
    highResImg: HTMLImageElement,
  ): void {
    highResImg.style.opacity = "1";
    lowResImg.style.opacity = "0";
  }

  function observeImages() {
    const imageContainers = document.querySelectorAll(".image-container");
    const observer = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadHighResImage(entry.target as HTMLElement);
            observer.unobserve(entry.target);
          }
        });
      },
      { rootMargin: "50px" },
    );

    imageContainers.forEach((container) => {
      observer.observe(container);
    });
  }

  // Run on initial load
  observeImages();

  // Run on subsequent navigations
  document.addEventListener("astro:page-load", observeImages);
</script>
