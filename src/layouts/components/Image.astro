---
interface Props {
  uuid: string;
  alt: string;
  sizes?: string;
  breakpoints?: number[];
  className?: string;
  crop?: boolean;
  isBackground?: boolean;
}

interface ImageDimensions {
  width: number;
  height: number;
}

const {
  uuid,
  alt,
  sizes = "sm:100vw md:50vw lg:33vw",
  breakpoints = [640, 768, 1024, 1280, 1536],
  className = "",
  crop = false,
  isBackground = false,
} = Astro.props as Props;

const baseUrl = `https://ucarecdn.com/${uuid}/`;

const imageDimensionsCache: { [key: string]: ImageDimensions } = {};

import imageDimensions from "./imageDimensions.json";

async function fetchImageDimensions(uuid: string): Promise<ImageDimensions> {
  const cacheKey = `image-dimensions-${uuid}`;

  // Check pre-fetched dimensions
  if (imageDimensions[uuid]) {
    return imageDimensions[uuid];
  }

  // Check in-memory cache (for server-side rendering)
  if (imageDimensionsCache[cacheKey]) {
    return imageDimensionsCache[cacheKey];
  }

  // Check localStorage (for client-side rendering)
  if (typeof window !== "undefined") {
    const cachedDimensions = localStorage.getItem(cacheKey);
    if (cachedDimensions) {
      return JSON.parse(cachedDimensions);
    }
  }

  // Fetch from API
  const response = await fetch(`https://ucarecdn.com/${uuid}/-/json/`);
  const data = await response.json();
  const dimensions = { width: data.width, height: data.height };

  // Store in in-memory cache
  imageDimensionsCache[cacheKey] = dimensions;

  // Store in localStorage (for client-side rendering)
  if (typeof window !== "undefined") {
    localStorage.setItem(cacheKey, JSON.stringify(dimensions));
  }

  return dimensions;
}

const { width: originalWidth, height: originalHeight } =
  await fetchImageDimensions(uuid);
const aspectRatio = originalWidth / originalHeight;

function generateSrcSet(
  breakpoints: number[],
  aspectRatio: number,
  crop: boolean,
): string {
  const srcSet = breakpoints
    .map((width) => {
      const height = Math.round(width / aspectRatio);
      const cropParam = crop
        ? `-/crop/${width}x${height}/center/`
        : `-/resize/${width}x${height}/`;
      return `${baseUrl}${cropParam}-/format/auto/-/quality/smart/ ${width}w`;
    })
    .join(", ");
  return srcSet;
}

function parseTailwindSizes(sizes: string): string {
  const breakpointMap: { [key: string]: number } = {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    "2xl": 1536,
  };

  const parts = sizes.split(" ").reverse();
  const result: string[] = [];

  for (const part of parts) {
    const [breakpoint, size] = part.split(":");
    if (breakpoint && breakpointMap[breakpoint]) {
      result.push(`(min-width: ${breakpointMap[breakpoint]}px) ${size}`);
    } else {
      result.push(size);
    }
  }

  return result.join(", ");
}

const srcset = generateSrcSet(breakpoints, aspectRatio, crop);
const parsedSizes = parseTailwindSizes(sizes);
const largestBreakpoint = breakpoints[breakpoints.length - 1];
const largestHeight = Math.round(largestBreakpoint / aspectRatio);
const cropParam = crop
  ? `-/crop/${largestBreakpoint}x${largestHeight}/center/`
  : `-/resize/${largestBreakpoint}x${largestHeight}/`;
const largestImageUrl = `${baseUrl}${cropParam}-/format/auto/-/quality/smart/`;
const largestBackgroundImageUrl = `${baseUrl}-/resize/${largestBreakpoint}x${largestHeight}/-/format/auto/-/quality/smart/`;

function generateLowResSrc(uuid: string): string {
  return `${baseUrl}-/resize/20x/-/format/auto/-/quality/lightest/`;
}

const lowResImageUrl = generateLowResSrc(uuid);
---

{
  isBackground ? (
    <div
      class={`cs-background ${className}`}
      style={`
      background-image: url('${largestBackgroundImageUrl}');
      background-size: cover;
      background-position: center;
      aspect-ratio: ${aspectRatio};
    `}
      role="img"
      aria-label={alt}
    />
  ) : (
    <picture class="cs-picture">
      <img
        src={lowResImageUrl}
        data-src={largestImageUrl}
        srcset={srcset}
        sizes={parsedSizes}
        alt={alt}
        loading="eager"
        decoding="async"
        width={largestBreakpoint}
        height={largestHeight}
        style={`aspect-ratio: ${aspectRatio}; object-fit: cover;`}
        class={`responsive-image ${className} progressive-image`}
      />
    </picture>
  )
}

<script>
  function loadHighResImage(img: HTMLImageElement): void {
    const highResSrc = img.getAttribute("data-src");
    if (highResSrc) {
      const highResImg = new Image();
      highResImg.src = highResSrc;
      highResImg.onload = () => {
        img.src = highResSrc;
        img.classList.add("loaded");
      };
      highResImg.onerror = () => {
        console.error(`Failed to load high-res image: ${highResSrc}`);
      };
    } else {
      console.error("High-res image source is null or undefined.");
    }
  }

  function observeImages() {
    const images = document.querySelectorAll("img.progressive-image");
    const observer = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img instanceof HTMLImageElement) {
              loadHighResImage(img);
              observer.unobserve(img);
            }
          }
        });
      },
      { rootMargin: "50px" },
    );

    images.forEach((img) => {
      observer.observe(img);
    });
  }

  function logImageInfo() {
    const images = document.querySelectorAll("img.responsive-image");
    images.forEach((img, index) => {
      if (img instanceof HTMLImageElement) {
        console.log(`Image ${index + 1}:`);
        console.log("Viewport width:", window.innerWidth);
        console.log("Image natural width:", img.naturalWidth);
        console.log("Image displayed width:", img.offsetWidth);
        console.log("Current image src:", img.currentSrc);
        console.log("---");
      }
    });
  }

  function debounce<T extends (...args: any[]) => void>(
    func: T,
    wait: number,
  ): (...args: Parameters<T>) => void {
    let timeout: ReturnType<typeof setTimeout>;
    return function (this: unknown, ...args: Parameters<T>): void {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  function initImageLoading() {
    observeImages();
    logImageInfo();
  }

  const debouncedInitImageLoading = debounce(initImageLoading, 250);

  // Initialize on load and navigation
  window.addEventListener("load", initImageLoading);
  document.addEventListener("astro:page-load", initImageLoading);

  // Initialize on resize (debounced)
  window.addEventListener("resize", debouncedInitImageLoading);
</script>

<style>
  .progressive-image {
    filter: blur(10px);
    transition: filter 0.3s ease;
  }
  .progressive-image.loaded {
    filter: blur(0);
  }
</style>
